// use log::info;

// use super::config::WireguardSettings;
// use crate::{
//     utils::{os::{self}, misc},
//     wireguard::config::{self, WireguardMemento},
// };

// // pub async fn wg_start(settings: WireguardSettings) {
// //     let (wg, quick) = get_config().await;
// //     sync_config().await;
// //     let config_str = format_config(wg, quick).await;
// //     os::write_to_path_unhandled("/etc/wireguard/wg0.conf", config_str).await;
// //     _ = os::exec_bash(format!("wg-quick down wg0")).await;
// //     _ = os::exec_bash(format!("wg-quick up wg0")).await;
// //     //todo Add error feedback if host kernel does not support wireguard
// // }

// pub async fn get_config() -> (WireguardMemento, WireguardSettings) {
//     let quick = load_wireguard_settings("./quick_config.json").await;
//     log::info!("Loading configuration...");

//     let wg_config_path = &mut quick.wg_path.to_owned();
//     wg_config_path.push_str("/wg0");

//     let wg_config: WireguardMemento;
//     let (mut wg_config_file, wg_config_str) =
//         os::load_and_read_file_unhandled(wg_config_path).await;
//     if !wg_config_str.is_empty() {
//         wg_config = serde_json::from_str(wg_config_str.as_str()).unwrap();
//     } else {
//         info!("Creating new WireGuard configuration...");
//         let private_key = os::exec_bash(format!("wg genkey")).await;
//         let public_key = os::exec_bash(format!("echo {private_key} | wg pubkey")).await;
//         let address = quick.wg_default_address.repeat(1);
//         wg_config = WireguardMemento::new(config::Server {
//             private_key,
//             public_key,
//             address,
//         });
//         info!("WireGuard configuration generated...");
//         save_config_directly(&wg_config, &mut wg_config_file).await;
//     }
//     (wg_config, quick)
// }

// async fn save_config_directly(config: &WireguardMemento, file: &mut tokio::fs::File) {
//     let wg_config_str =
//         serde_json::to_string_pretty(config).expect("Could not serialize wg_config");
//     os::write_to_file_unhandled(file, wg_config_str).await;
// }

// async fn load_wireguard_settings(config_path: &str) -> WireguardSettings {
//     let (_, config_str) = os::load_and_read_file_unhandled(config_path).await;

//     match serde_json::from_str(&config_str) {
//         Ok(config) => config,
//         Err(error) => {
//             log::error!(
//                 "Could not parse settings {}: {}",
//                 config_path,
//                 error.to_string()
//             );
//             panic!()
//         }
//     }
// }

// async fn sync_config() {
//     info!("Config syncing...");
//     os::exec_bash(format!("wg syncconf wg0 <(wg-quick strip wg0)")).await;
//     info!("Config synced...");
//     os::exec_bash(format!("wg syncconf wg0 <(wg-quick strip wg0)")).await;
// }

// // async fn format_config(config: WireguardMemento, quick: WireguardSettings) -> String {
// //     let result_vec = vec![
// //         format!("# Note: Do not edit this file directly.\n"),
// //         format!("# Your changes will be overwritten!\n"),
// //         format!("\n"),
// //         format!("# Server\n"),
// //         format!("[Interface]\n"),
// //         format!("PrivateKey = {}\n", config.server.private_key),
// //         format!("Address = {}/24\n", config.server.address),
// //         format!("ListenPort = 51820\n"),
// //         format!("PreUp = {}\n", multi_line(quick.wg_pre_up)),
// //         format!("PostUp = {}\n", multi_line(quick.wg_post_up)),
// //         format!("PreDown = {}\n", multi_line(quick.wg_pre_down)),
// //         format!("PostDown = {}\n", multi_line(quick.wg_post_down)),
// //     ];
// //     let mut result = misc::multi_line(&result_vec);

// //     for (uid, client) in config.clients {
// //         if !client.enabled {
// //             continue;
// //         }
// //         let result_inner = vec![
// //             format!("\n"),
// //             format!("# Client: {} ({})\n", client.name, uid),
// //             format!("[Peer]\n"),
// //             format!("PublicKey = {}\n", client.public_key),
// //             format!("PresharedKey = {}\n", client.pre_shared_key),
// //             format!("AllowedIPs = {}/32\n", client.address),
// //         ];
// //         result.push_str(multi_line(result_inner).as_str());
// //     }
// //     result
// // }
